<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>@pxuanne</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: black;
      perspective: 1000px;
    }

    .firefly {
      position: absolute;
      width: 2px;
      height: 2px;
      background: white;
      border-radius: 50%;
      opacity: 0.6;
      animation: blink 2s infinite ease-in-out alternate;
    }

    @keyframes blink {
      0% { opacity: 0.2; transform: scale(1); }
      100% { opacity: 1; transform: scale(1.5); }
    }

    .scene {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: visible;
      transform-style: preserve-3d;
      transition: transform 0.1s ease-out; /* Gi·ªØ transition ƒë·ªÉ xoay m∆∞·ª£t m√† */
      will-change: transform;
      z-index: 10;
      transform: rotateX(45deg); /* ƒêi·ªÅu ch·ªânh gi√° tr·ªã 10deg ƒë·ªÉ thay ƒë·ªïi ƒë·ªô nghi√™ng */
      transform-origin: center center; /* ƒê·∫£m b·∫£o xoay quanh t√¢m */
    }

    .text {
      position: absolute;
      top: 0;
      font-family: 'Dancing Script', cursive;
      font-size: 35px;
      white-space: nowrap;
      pointer-events: none;
      animation:
        gentleFall 14s cubic-bezier(0.42, 0, 0.58, 1) infinite,
        rgbShift 14s ease-in-out infinite;
      opacity: 0;
      color: #fff;
      text-shadow:
        0 0 8px #fff,
        0 0 20px #f0f,
        0 0 30px #f00,
        0 0 40px #0ff,
        0 0 50px #f0f,
        0 0 60px #f00,
        0 0 70px #0ff;
      user-select: none;
      font-weight: 400;
      transform-origin: center;
    }

    @keyframes gentleFall {
      0% {
        transform: translateY(-10vh) scale(0.9);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      50% {
        transform: translateY(50vh) scale(1.2);
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        transform: translateY(110vh) scale(0.9);
        opacity: 0;
      }
    }

    @keyframes rgbShift {
      0%, 100% {
        color: #ffffff;
        text-shadow:
          0 0 8px #ffffff,
          0 0 20px #ff83a8,
          0 0 30px #d12c4b,
          0 0 40px #7feaff;
      }
      25% {
        color: #ff83a8;
        text-shadow:
          0 0 8px #ff83a8,
          0 0 20px #ff5e7f,
          0 0 30px #d12c4b,
          0 0 40px #7feaff;
      }
      50% {
        color: #d12c4b;
        text-shadow:
          0 0 8px #d12c4b,
          0 0 20px #ff2a82,
          0 0 30px #8b1031,
          0 0 40px #7feaff;
      }
      75% {
        color: #7feaff;
        text-shadow:
          0 0 8px #7feaff,
          0 0 20px #4ec9ff,
          0 0 30px #2185a1,
          0 0 40px #7feaff;
      }
    }

    .heart {
      font-size: 48px;
    }

    .petal {
      position: absolute;
      width: 12px;
      height: 18px;
      background: radial-gradient(ellipse at center, #ff5e7f 60%, #d12c4b 100%);
      border-radius: 60% 40% 60% 40% / 70% 90% 10% 30%;
      opacity: 0.85;
      pointer-events: none;
      animation: petalFall linear infinite;
      filter: drop-shadow(0 0 2px #d12c4b);
      transform-origin: center;
    }

    @keyframes petalFall {
      0% {
        transform: translateY(-10vh) rotate(0deg) translateX(0);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      100% {
        transform: translateY(110vh) rotate(360deg) translateX(30px);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div class="scene" id="scene"></div>

  <script>
    const texts = [
      "Ch√∫c m·ª´ng sinh nh·∫≠t b·∫°n Changgüê£", "Th√™m xinh g√°i", "Th√™m h·ªçc gi·ªèi", "ƒê·∫°t ƒë∆∞·ª£c ∆∞·ªõc m∆°", "nhi·ªÅu xi·ªÅn üíµ",
      "H·∫°nh ph√∫c", "May m·∫Øn"
    ];

    const scene = document.getElementById('scene');

    // Zoom & Rotation variables
    let scale = 1;
    let rotateX = 0;
    let rotateY = 0;

    // Variables for mouse/touch rotation
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let targetRotateX = 0; // Target rotation for smoother animation
    let targetRotateY = 0; // Target rotation for smoother animation


    function updateSceneTransform() {
      // Apply both scale and rotation
      scene.style.transform = `scale(${scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
    }

    // Zoom functionality (from previous version, remains unchanged)
    document.addEventListener('wheel', function (e) {
      e.preventDefault();
      scale += e.deltaY * -0.001;
      scale = Math.min(Math.max(0.5, scale), 2);
      updateSceneTransform();
    }, { passive: false });

    let initialDistance = null;

    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    scene.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        initialDistance = getDistance(e.touches);
      } else if (e.touches.length === 1) { // Single touch for rotation
        e.preventDefault(); // Prevent scrolling
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
        isDragging = true;
        // Optionally, if you have background music, you can play it here on first interaction
        // if (audio.paused) { audio.play().catch(err => console.log("Kh√¥ng th·ªÉ ph√°t t·ª± ƒë·ªông:", err)); }
      }
    }, { passive: false });

    scene.addEventListener('touchmove', e => {
      if (e.touches.length === 2 && initialDistance !== null) {
        e.preventDefault();
        const currentDistance = getDistance(e.touches);
        const delta = currentDistance - initialDistance;
        scale += delta * 0.002;
        scale = Math.min(Math.max(0.5, scale), 2);
        updateSceneTransform();
        initialDistance = currentDistance;
      } else if (e.touches.length === 1 && isDragging) { // Single touch for rotation
        e.preventDefault();
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;

        const deltaX = (touchX - lastMouseX) * 0.5; // Adjust sensitivity
        const deltaY = (touchY - lastMouseY) * 0.5; // Adjust sensitivity

        targetRotateY += deltaX;
        targetRotateX -= deltaY; // Invert for more natural up/down rotation

        lastMouseX = touchX;
        lastMouseY = touchY;
      }
    }, { passive: false });

    scene.addEventListener('touchend', e => {
      if (e.touches.length < 2) { // Reset initialDistance if less than 2 touches
        initialDistance = null;
      }
      // If no touches are left, stop dragging
      if (e.touches.length === 0) {
        isDragging = false;
        // Optionally, reset target rotation for a "snap back" effect
        // targetRotateX = 0;
        // targetRotateY = 0;
      }
    });

    // Mouse events for rotation
    document.addEventListener("mousedown", (e) => {
        isDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
    });

    document.addEventListener("mousemove", (e) => {
        if (isDragging) {
            const deltaX = (e.clientX - lastMouseX) * 0.5; // Adjust sensitivity
            const deltaY = (e.clientY - lastMouseY) * 0.5; // Adjust sensitivity

            targetRotateY += deltaX;
            targetRotateX += deltaY; // Keep this as is for standard mouse rotation

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
    });

    document.addEventListener("mouseup", () => {
        isDragging = false;
        // Optionally, reset target rotation for a "snap back" effect
        // targetRotateX = 0;
        // targetRotateY = 0;
    });

    // Animation loop for smooth rotation
    function updateRotation() {
        rotateX += (targetRotateX - rotateX) * 0.1; // Smoothly move towards target
        rotateY += (targetRotateY - rotateY) * 0.1; // Smoothly move towards target
        updateSceneTransform(); // Update the scene's transform
        requestAnimationFrame(updateRotation);
    }
    updateRotation(); // Start the rotation animation loop


    function createText() {
      const el = document.createElement("div");
      const content = texts[Math.floor(Math.random() * texts.length)];
      el.className = "text";
      if (content === "‚ù§Ô∏è") el.classList.add("heart");
      el.textContent = content;

      const left = Math.random() * 100;
      const duration = 14;
      const delay = Math.random() * 6;

      el.style.left = left + "vw";
      el.style.top = "0";
      el.style.animationDuration = `${duration}s, ${duration}s`;
      el.style.animationDelay = `${delay}s, ${delay}s`;
      scene.appendChild(el);

      setTimeout(() => {
        scene.removeChild(el);
      }, (duration + delay) * 1000);
    }

    setInterval(createText, 800);
    for (let i = 0; i < 10; i++) createText();

    for (let i = 0; i < 80; i++) {
      const firefly = document.createElement('div');
      firefly.className = 'firefly';
      firefly.style.left = Math.random() * 100 + 'vw';
      firefly.style.top = Math.random() * 100 + 'vh';
      firefly.style.animationDuration = (1 + Math.random() * 2) + 's';
      document.body.appendChild(firefly);
    }

    function createPetal() {
      const petal = document.createElement('div');
      petal.className = 'text'; // Keep the 'text' class for shared styles like font, opacity
      const icons = ['üéÇ', 'üéâ', 'üíØ'];
      petal.textContent = icons[Math.floor(Math.random() * icons.length)];

      const left = Math.random() * 100;
      const duration = 10 + Math.random() * 5;
      const delay = Math.random() * 5;

      petal.style.left = left + "vw";
      petal.style.top = "-5vh";
      petal.style.animation = `petalFall ${duration}s linear ${delay}s forwards`;
      petal.style.fontSize = "32px";
      petal.style.opacity = 0;

      scene.appendChild(petal);

      setTimeout(() => {
        scene.removeChild(petal);
      }, (duration + delay) * 1000);
    }

    setInterval(createPetal, 1000);
    for (let i = 0; i < 5; i++) createPetal();

  </script>
</body>
</html>
